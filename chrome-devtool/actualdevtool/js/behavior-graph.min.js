/**
 * Minified by jsDelivr using Terser v5.15.1.
 * Original file: /npm/behavior-graph@1.2.0/lib/behavior-graph.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var bg=function(e){"use strict";class t{queue=[];buffer=[];constructor(){}push(e){this.buffer.push(e)}peek(){return 0==this.length?void 0:(this.heapifyBuffer(),this.queue[0])}pop(){if(0!=this.length){this.heapifyBuffer();let e=this.queue[0],t=this.queue.pop();return this.queue.length>0&&(this.queue[0]=t,this.down(0)),e}}heapifyBuffer(){for(let e=0;e<this.buffer.length;e++){let t=this.buffer[e];this.queue.push(t),this.queue.length>1&&this.up(this.queue.length-1)}this.buffer.length=0}get length(){return this.queue.length+this.buffer.length}unsort(){this.buffer=this.buffer.concat(this.queue),this.queue.length=0}clear(){this.queue.length=0,this.buffer.length=0}up(e){let t=this.queue[e];for(;e>0;){let i=e-1>>1,n=this.queue[i];if(t.order>=n.order)break;this.queue[e]=n,e=i}this.queue[e]=t}down(e){const t=this.queue.length>>1,i=this.queue[e];for(;e<t;){let t=1+(e<<1),n=this.queue[t];const r=t+1;if(r<this.queue.length&&this.queue[r].order<n.order&&(t=r,n=this.queue[r]),n.order>=i.order)break;this.queue[e]=n,e=t}this.queue[e]=i}}var i,n;!function(e){e[e.reactive=0]="reactive",e[e.order=1]="order"}(i||(i={}));class r{debugName;isResource=!0;extent;graph;subsequents=new Set;suppliedBy=null;skipChecks=!1;didUpdateSubscribers;constructor(e,t){this.extent=e,this.graph=e.graph,e.addResource(this),this.debugName=void 0!==t?t:null}get order(){return{resource:this,type:i.order}}get resource(){return this}get type(){return i.reactive}toString(){let e="Resource";return null!=this.debugName&&(e=this.debugName+"(r)"),e}assertValidUpdater(){let e=this.graph,t=e.currentBehavior,i=e.currentEvent;if(null==t&&null==i){let e=new Error("Resource must be updated inside a behavior or action.");throw e.resource=this,e}if(!this.skipChecks){if(this.suppliedBy&&t!=this.suppliedBy){let e=new Error("Supplied resource can only be updated by its supplying behavior.");throw e.resource=this,e.currentBehavior=t,e}if(null==this.suppliedBy&&null!=t){let e=new Error("Unsupplied resource can only be updated in an action.");throw e.resource=this,e.currentBehavior=t,e}}}assertValidAccessor(){let e=this.graph.currentBehavior;if(null!=e&&e!=this.suppliedBy&&!e.demands?.has(this)){let t=new Error("Cannot access the value or event of a resource inside a behavior unless it is supplied or demanded.");throw t.resource=this,t.currentBehavior=e,t}}get justUpdated(){return this.assertValidAccessor(),!1}subscribeToJustUpdated(e){return void 0===this.didUpdateSubscribers&&(this.didUpdateSubscribers=new Set),this.didUpdateSubscribers.add(e),()=>{this.didUpdateSubscribers.delete(e)}}notifyJustUpdatedSubscribers(){void 0!==this.didUpdateSubscribers&&this.didUpdateSubscribers.size>0&&this.extent.sideEffect((e=>{this.didUpdateSubscribers?.forEach((function(e){e()}))}))}}class s extends r{_happened=!1;_happenedValue=void 0;_happenedWhen=null;get justUpdated(){return this.assertValidAccessor(),this._happened}get value(){return this.assertValidAccessor(),this._happenedValue}get event(){return this.assertValidAccessor(),this._happenedWhen}toString(){let e="Moment";return null!=this.debugName&&(e=this.debugName+"(m)"),void 0!==this._happenedValue&&(e=e+"="+this._happenedValue),null!==this._happenedWhen&&(e=e+" : "+this._happenedWhen.sequence),e}justUpdatedTo(e){return this.justUpdated&&this._happenedValue==e}updateWithAction(e,t){this.graph.action((()=>{this.update(e)}),t)}update(e){this.assertValidUpdater(),this._happened=!0,this._happenedValue=e,this._happenedWhen=this.graph.currentEvent,this.notifyJustUpdatedSubscribers(),this.graph.resourceTouched(this),this.graph.trackTransient(this)}clear(){this._happened=!1,this._happenedValue=void 0}}class a extends r{currentState;previousState=null;constructor(e,t,i){super(e,i),this.currentState={value:t,event:h.initialEvent}}toString(){let e="State";return null!=this.debugName&&(e=this.debugName+"(s)"),e=e+"="+this.currentState.value,e=e+" : "+this.currentState.event.sequence,e}updateWithAction(e,t){this.graph.action((()=>{this.update(e)}),t)}update(e){this.currentState.value!==e&&this.updateForce(e)}updateForce(e){this.assertValidUpdater(),this._updateForce(e)}_updateForce(e){null!=this.graph.currentEvent&&this.currentState.event.sequence<this.graph.currentEvent?.sequence&&(this.previousState=this.currentState),this.currentState={value:e,event:this.graph.currentEvent},this.notifyJustUpdatedSubscribers(),this.graph.resourceTouched(this),this.graph.trackTransient(this)}clear(){this.previousState=null}get value(){return this.assertValidAccessor(),this.currentState.value}get event(){return this.assertValidAccessor(),this.currentState.event}get trace(){return this.currentState.event===this.graph.currentEvent?this.previousState:this.currentState}get traceValue(){return this.trace.value}get traceEvent(){return this.trace.event}get justUpdated(){return this.assertValidAccessor(),this.currentState.event===this.graph.currentEvent}justUpdatedTo(e){return this.justUpdated&&this.currentState.value==e}justUpdatedFrom(e){return this.justUpdated&&this.traceValue==e}justUpdatedToFrom(e,t){return this.justUpdatedTo(e)&&this.justUpdatedFrom(t)}}!function(e){e[e.Untracked=0]="Untracked",e[e.NeedsOrdering=1]="NeedsOrdering",e[e.Clearing=2]="Clearing",e[e.Ordering=3]="Ordering",e[e.Ordered=4]="Ordered"}(n||(n={}));const d={now:()=>new Date};class h{sequence;timestamp;static initialEvent=new h(0,new Date(0));constructor(e,t){this.sequence=e,this.timestamp=t}}var l,u,o;!function(e){e[e.queued=0]="queued",e[e.action=1]="action",e[e.updates=2]="updates",e[e.sideEffects=3]="sideEffects"}(l||(l={}));class c{action;actionUpdates;currentSideEffect=null;phase;constructor(e){this.action=e,this.phase=l.queued,this.actionUpdates=[]}}e.RelinkingOrder=void 0,(u=e.RelinkingOrder||(e.RelinkingOrder={}))[u.relinkingOrderPrior=0]="relinkingOrderPrior",u[u.relinkingOrderSubsequent=1]="relinkingOrderSubsequent";class p{demands;orderingDemands;supplies;block;enqueuedWhen=null;removedWhen=null;extent;orderingState=n.Untracked;order=0;untrackedDemands;untrackedDynamicDemands;untrackedSupplies;untrackedDynamicSupplies;constructor(e,t,i,n){this.extent=e,e.addBehavior(this),this.demands=null,this.orderingDemands=null,this.supplies=null,this.block=n,this.untrackedDemands=t,this.untrackedDynamicDemands=null,this.untrackedSupplies=i,this.untrackedDynamicSupplies=null}toString(){let e="Behavior ("+this.order+")";return null!=this.enqueuedWhen&&(e=e+" : "+this.enqueuedWhen),null!=this.supplies&&this.supplies?.size>0&&(e+=" \n Supplies:",this.supplies?.forEach((t=>{e=e+"\n  "+t.toString()}))),null!=this.demands&&this.demands?.size>0&&(e+=" \n Demands:",this.demands?.forEach((t=>{e=e+"\n  "+t.toString()}))),e}setDynamicDemands(e){this.extent.graph.updateDemands(this,e?.filter((e=>null!=e)))}setDynamicSupplies(e){this.extent.graph.updateSupplies(this,e?.filter((e=>void 0!==e)))}}class f{extent;untrackedDemands=null;untrackedSupplies=null;dynamicDemandSwitches=null;dynamicDemandLinks=null;dynamicDemandRelinkingOrder=e.RelinkingOrder.relinkingOrderPrior;dynamicSupplySwitches=null;dynamicSupplyLinks=null;dynamicSupplyRelinkingOrder=e.RelinkingOrder.relinkingOrderPrior;constructor(e){this.extent=e}demands(...e){return this.untrackedDemands=e,this}supplies(...e){return this.untrackedSupplies=e,this}dynamicDemands(e,t,i){return this.dynamicDemandSwitches=e,this.dynamicDemandLinks=t,null!=i&&(this.dynamicDemandRelinkingOrder=i),this}dynamicSupplies(e,t,i){return this.dynamicSupplySwitches=e,this.dynamicSupplyLinks=t,null!=i&&(this.dynamicSupplyRelinkingOrder=i),this}runs(t){let i,n=null!=this.dynamicDemandSwitches;null==this.untrackedDemands&&(this.untrackedDemands=[]),null==this.untrackedSupplies&&(this.untrackedSupplies=[]),n&&(i=this.extent.resource("(BG Dynamic Demand Resource)"),this.dynamicDemandRelinkingOrder==e.RelinkingOrder.relinkingOrderPrior?this.untrackedDemands.push(i):this.untrackedSupplies.push(i));let r,s=null!=this.dynamicSupplySwitches;s&&(r=this.extent.resource("(BG Dynamic Supply Resource)"),this.dynamicSupplyRelinkingOrder==e.RelinkingOrder.relinkingOrderPrior?this.untrackedDemands.push(r):this.untrackedSupplies.push(r));let a=new p(this.extent,this.untrackedDemands,this.untrackedSupplies,t);if(n){let t=[],n=this.dynamicDemandSwitches;this.dynamicDemandRelinkingOrder==e.RelinkingOrder.relinkingOrderPrior?t.push(i):(null==n&&(n=[]),n.push(i)),new p(this.extent,n,t,(e=>{let t=this.dynamicDemandLinks(e);a.setDynamicDemands(t)}))}if(s){let t=[],i=this.dynamicSupplySwitches;this.dynamicSupplyRelinkingOrder==e.RelinkingOrder.relinkingOrderPrior?t.push(r):(null==i&&(i=[]),i.push(r)),new p(this.extent,i,t,(e=>{let t=this.dynamicSupplyLinks(e);a.setDynamicSupplies(t)}))}return a}}e.ExtentRemoveStrategy=void 0,(o=e.ExtentRemoveStrategy||(e.ExtentRemoveStrategy={}))[o.extentOnly=0]="extentOnly",o[o.containedLifetimes=1]="containedLifetimes";class m{addedToGraphWhen=null;extents=new Set;children=null;parent=null;constructor(e){this.extents.add(e),null!=e.addedToGraphWhen&&(this.addedToGraphWhen=e.addedToGraphWhen)}unify(e){if(null!=e.addedToGraphWhen){let t=new Error("Same lifetime relationship must be established before adding any extent to graph.");throw t.extent=e,t}if(null!=e.lifetime){if(null!=e.lifetime.children)for(let t of e.lifetime.children)this.addChildLifetime(t);for(let t of e.lifetime.extents)t.lifetime=this,this.extents.add(t)}else e.lifetime=this,this.extents.add(e)}addChild(e){null==e.lifetime&&(e.lifetime=new m(e)),this.addChildLifetime(e.lifetime)}addChildLifetime(e){let t=this;for(;null!=t;){if(t===e){let t=new Error("Child lifetime cannot be a transitive parent.");throw t.extent=e,t}t=t.parent}e.parent=this,null==this.children&&(this.children=new Set),this.children.add(e)}hasCompatibleLifetime(e){return this===e||null!=e&&null!=this.parent&&this.parent.hasCompatibleLifetime(e)}getAllContainedExtents(){let e=[];for(let t of this.extents)e.push(t);if(null!=this.children)for(let t of this.children)e.push(...t.getAllContainedExtents());return e}getAllContainingExtents(){let e=[];for(let t of this.extents)e.push(t);return null!=this.parent&&e.push(...this.parent.getAllContainingExtents()),e}}class v{debugConstructorName;debugName;behaviors=[];resources=[];graph;addedToGraphWhen=null;addedToGraph;lifetime=null;static removeContainedLifetimes=e.ExtentRemoveStrategy.containedLifetimes;static relinkingOrderSubsequent=e.RelinkingOrder.relinkingOrderSubsequent;constructor(e){if(null==e){let e=new Error("Extent must be initialized with an instance of Graph");throw e.extent=this,e}this.debugConstructorName=this.constructor.name,this.graph=e,this.addedToGraph=new a(this,!1)}debugHere(){return this.graph.debugHere()}unifyLifetime(e){null==this.lifetime&&(this.lifetime=new m(this)),this.lifetime.unify(e)}addChildLifetime(e){null==this.lifetime&&(this.lifetime=new m(this)),this.lifetime.addChild(e)}hasCompatibleLifetime(e){return this===e||null!=this.lifetime&&this.lifetime.hasCompatibleLifetime(e.lifetime)}addBehavior(e){this.behaviors.push(e)}addResource(e){this.resources.push(e)}addToGraphWithAction(e){this.graph.action((()=>{this.addToGraph()}),e)}addToGraph(){if(null==this.graph.currentEvent){let e=new Error("addToGraph must be called within an event.");throw e.extent=this,e}this.nameResources(),this.graph.addExtent(this)}removeFromGraphWithAction(e,t){this.action((()=>{this.removeFromGraph(e)}),t)}removeFromGraph(t){let i=this.graph;if(null==i.currentEvent){let e=new Error("removeFromGraph must be called within an event.");throw e.extent=this,e}if(null!=this.addedToGraphWhen)if(t==e.ExtentRemoveStrategy.extentOnly||void 0===t||null===this.lifetime)i.removeExtent(this);else for(let e of this.lifetime.getAllContainedExtents())i.removeExtent(e)}nameResources(){for(let e in this){let t=this[e];t&&void 0!==t.isResource&&null==t.debugName&&(t.debugName=e)}}behavior(){return new f(this)}resource(e){return new r(this,e)}moment(e){return new s(this,e)}state(e,t){return new a(this,e,t)}sideEffect(e,t){this.graph.sideEffectHelper({debugName:t,block:e,extent:this,behavior:this.graph.currentBehavior})}async actionAsync(e,t){return this.graph.actionAsyncHelper({block:e,debugName:t,extent:this,resolve:null})}action(e,t){this.graph.actionHelper({block:e,debugName:t,extent:this,resolve:null})}}return e.Behavior=p,e.Extent=v,e.Graph=class{dateProvider=d;currentEvent=null;lastEvent;activatedBehaviors=new t;currentBehavior=null;effects=[];actions=[];untrackedBehaviors=[];modifiedDemandBehaviors=[];modifiedSupplyBehaviors=[];updatedTransients=[];needsOrdering=[];eventLoopState=null;extentsAdded=[];extentsRemoved=[];validateLifetimes=!0;constructor(){this.lastEvent=h.initialEvent}action(e,t){this.actionHelper({debugName:t,block:e,extent:null,resolve:null})}actionHelper(e){if(null!=this.eventLoopState&&(this.eventLoopState.phase==l.action||this.eventLoopState.phase==l.updates)){throw new Error("Action cannot be created directly inside another action or behavior. Consider wrapping it in a side effect block.")}this.actions.push(e),this.eventLoop()}async actionAsync(e,t){return this.actionAsyncHelper({debugName:t,block:e,extent:null,resolve:null})}async actionAsyncHelper(e){return new Promise(((t,i)=>{try{if(null!=this.eventLoopState&&(this.eventLoopState.phase==l.action||this.eventLoopState.phase==l.updates)){throw new Error("Action cannot be created directly inside another action or behavior. Consider wrapping it in a side effect block.")}e.resolve=t,this.actions.push(e),null==this.currentEvent&&this.eventLoop()}catch(e){i(e)}}))}eventLoop(){for(;;){try{if(this.activatedBehaviors.length>0||this.untrackedBehaviors.length>0||this.modifiedDemandBehaviors.length>0||this.modifiedSupplyBehaviors.length>0||this.needsOrdering.length>0){this.eventLoopState.phase=l.updates;let e=this.currentEvent.sequence;this.addUntrackedBehaviors(),this.addUntrackedSupplies(),this.addUntrackedDemands(e),this.orderBehaviors(),this.runNextBehavior(e);continue}this.validateLifetimes&&(this.extentsAdded.length>0&&(this.validateAddedExtents(),this.extentsAdded.length=0),this.extentsRemoved.length>0&&(this.validateRemovedExtents(),this.extentsRemoved.length=0));let e=this.effects.shift();if(e){this.eventLoopState.phase=l.sideEffects,this.eventLoopState.currentSideEffect=e,e.block(e.extent),null!=this.eventLoopState&&(this.eventLoopState.currentSideEffect=null);continue}this.currentEvent&&(null!=this.eventLoopState.action.resolve&&this.eventLoopState.action.resolve(void 0),this.clearTransients(),this.lastEvent=this.currentEvent,this.currentEvent=null,this.eventLoopState=null,this.currentBehavior=null);let t=this.actions.shift();if(t){let e=new h(this.lastEvent.sequence+1,this.dateProvider.now());this.currentEvent=e,this.eventLoopState=new c(t),this.eventLoopState.phase=l.action,t.block(t.extent);continue}}catch(e){throw this.currentEvent=null,this.eventLoopState=null,this.actions.length=0,this.effects.length=0,this.currentBehavior=null,this.activatedBehaviors.clear(),this.clearTransients(),this.modifiedDemandBehaviors.length=0,this.modifiedSupplyBehaviors.length=0,this.untrackedBehaviors.length=0,this.extentsAdded.length=0,this.extentsRemoved.length=0,e}break}}validateAddedExtents(){let e=new Set;for(let t of this.extentsAdded)if(null!=t.lifetime)for(let i of t.lifetime.getAllContainingExtents())null==i.addedToGraphWhen&&e.add(i);if(e.size>0){let t=new Error("All extents with unified or parent lifetimes must be added during the same event.");throw t.nonAddedExtents=e,t}}validateRemovedExtents(){let e=new Set;for(let t of this.extentsRemoved)if(null!=t.lifetime)for(let i of t.lifetime.getAllContainedExtents())null!=i.addedToGraphWhen&&e.add(i);if(e.size>0){let t=new Error("All extents with unified or child lifetimes must be removed during the same event.");throw t.nonAddedExtents=e,t}for(let e of this.extentsRemoved)for(let t of e.resources){for(let e of t.subsequents)if(null!=e.extent.addedToGraphWhen){let i=new Error("Remaining behaviors must remove dynamicDemands to removed resources.");throw i.remainingBehavior=e,i.removedResource=t,i}if(null!=t.suppliedBy&&null!=t.suppliedBy.extent.addedToGraphWhen){let e=new Error("Remaining behaviors must remove dynamicSupplies to removed resources.");throw e.remainingBehavior=t.suppliedBy,e.removedResource=t,e}}}clearTransients(){if(this.updatedTransients.length>0){for(let e of this.updatedTransients)e.clear();this.updatedTransients.length=0}}trackTransient(e){this.updatedTransients.push(e)}resourceTouched(e){if(null!=this.currentEvent){null!=this.eventLoopState&&this.eventLoopState.phase==l.action&&this.eventLoopState.actionUpdates.push(e);for(let t of e.subsequents){null!=t.orderingDemands&&t.orderingDemands.has(e)||this.activateBehavior(t,this.currentEvent.sequence)}}}activateBehavior(e,t){(null==e.enqueuedWhen||e.enqueuedWhen<t)&&(e.enqueuedWhen=t,this.activatedBehaviors.push(e))}runNextBehavior(e){let t=this.activatedBehaviors.pop();for(;void 0!==t;)if(t.removedWhen==e)t=this.activatedBehaviors.pop();else{this.currentBehavior=t,t.block(t.extent),this.currentBehavior=null;let e=this.activatedBehaviors.peek();if(void 0===e||e.order!=t.order)break;t=this.activatedBehaviors.pop()}}sideEffect(e,t){this.sideEffectHelper({debugName:t,block:e,behavior:null,extent:null})}sideEffectHelper(e){if(null==this.currentEvent){throw new Error("Effects can only be added during an event.")}if(this.eventLoopState.phase==l.sideEffects){throw new Error("Nested side effects don't make sense")}this.effects.push(e)}debugHere(){let e="";return null!=this.currentEvent?(e="Current Event: "+this.currentEvent.sequence+"\n",e+="Action Updates:\n",this.eventLoopState?.actionUpdates.forEach((t=>{e=e+" "+t.toString()+"\n"})),null!=this.currentBehavior&&(e+="Current Behavior:\n",e+=this.currentBehavior.toString())):e="No current event.",e}addUntrackedBehaviors(){if(this.untrackedBehaviors.length>0){for(let e of this.untrackedBehaviors)this.modifiedDemandBehaviors.push(e),this.modifiedSupplyBehaviors.push(e);this.untrackedBehaviors=[]}}addUntrackedSupplies(){if(this.modifiedSupplyBehaviors.length>0){for(let e of this.modifiedSupplyBehaviors){if(null!=e.untrackedSupplies)for(let t of e.untrackedSupplies)if(this.validateLifetimes&&!e.extent.hasCompatibleLifetime(t.extent)){let i=new Error("Static supplies can only be with extents with the unified or parent lifetimes.");throw i.currentBehavior=e,i.supply=t,i}let t=[...e.untrackedSupplies??[],...e.untrackedDynamicSupplies??[]];if(null!=e.supplies)for(let t of e.supplies)t.suppliedBy=null;e.supplies=new Set(t);for(let t of e.supplies){if(null!=t.suppliedBy&&t.suppliedBy!=e){let i=new Error("Resource cannot be supplied by more than one behavior.");throw i.alreadySupplied=t,i.desiredSupplier=e,i}t.suppliedBy=e}e.orderingState!=n.NeedsOrdering&&(e.orderingState=n.NeedsOrdering,this.needsOrdering.push(e))}this.modifiedSupplyBehaviors.length=0}}addUntrackedDemands(e){if(this.modifiedDemandBehaviors.length>0){for(let t of this.modifiedDemandBehaviors){if(null!=t.untrackedDemands)for(let e of t.untrackedDemands)if(this.validateLifetimes&&!t.extent.hasCompatibleLifetime(e.resource.extent)){let i=new Error("Static demands can only be with extents with the unified or parent lifetimes.");throw i.currentBehavior=t,i.demand=e.resource,i}let r,s,a=[...t.untrackedDemands??[],...t.untrackedDynamicDemands??[]];if(null!=t.demands)for(let e of t.demands)a.some((t=>t.resource==e))||(null==r&&(r=[]),r.push(e));for(let e of a){let i=e.resource;if(null==i.extent.addedToGraphWhen){let e=new Error("All demands must be added to the graph.");throw e.currentBehavior=t,e.untrackedDemand=i,e}null!=t.demands&&t.demands.has(i)||(null==s&&(s=[]),s.push(i))}let d=!1;if(null!=r)for(let e of r)e.subsequents.delete(t);let h=t.orderingState!=n.Ordered;if(null!=s)for(let e of s)if(e.subsequents.add(t),e.justUpdated&&(d=!0),!h){let i=e.suppliedBy;null!=i&&i.orderingState==n.Ordered&&i.order>=t.order&&(h=!0)}let l=null,u=null;for(let e of a)null==l&&(l=new Set),l.add(e.resource),e.type==i.order&&(null==u&&(u=new Set),u.add(e.resource));t.demands=l,t.orderingDemands=u,h&&t.orderingState!=n.NeedsOrdering&&(t.orderingState=n.NeedsOrdering,this.needsOrdering.push(t)),d&&this.activateBehavior(t,e)}this.modifiedDemandBehaviors.length=0}}orderBehaviors(){if(0==this.needsOrdering.length)return;let e=[],t=0;for(;t<this.needsOrdering.length;){let i=this.needsOrdering[t];if(i.orderingState==n.NeedsOrdering&&(i.orderingState=n.Clearing,e.push(i),i.supplies))for(let e of i.supplies)for(let t of e.subsequents)t.orderingState==n.Ordered&&(t.orderingState=n.NeedsOrdering,this.needsOrdering.push(t));t++}this.needsOrdering.length=0;let i={value:!1};for(let t of e)this.sortDFS(t,i);i.value&&this.activatedBehaviors.unsort()}sortDFS(e,t){if(e.orderingState==n.Ordering){let t=new Error("Behavior dependency cycle detected.");throw t.currentBehavior=e,t.cycle=this.debugCycleForBehavior(e),t}if(e.orderingState==n.Clearing){e.orderingState=n.Ordering;let i=0;if(null!=e.demands)for(let r of e.demands){let e=r.suppliedBy;null!=e&&(e.orderingState!=n.Ordered&&this.sortDFS(e,t),i=Math.max(i,e.order+1))}e.orderingState=n.Ordered,i!=e.order&&(e.order=i,t.value=!0)}}debugCycleForBehavior(e){let t=[],i=[];return this.cycleDFS(e,e,t)&&(i=t),i}cycleDFS(e,t,i){if(null!=e.demands)for(let n of e.demands){let e=n.suppliedBy;if(null!=e){if(i.push(n),e==t)return!0;if(this.cycleDFS(e,t,i))return!0;i.pop()}}return!1}addBehavior(e){this.untrackedBehaviors.push(e)}updateDemands(e,t){if(null==e.extent.addedToGraphWhen){let t=new Error("Behavior must belong to graph before updating demands.");throw t.behavior=e,t}if(null==this.currentEvent){let t=new Error("Demands can only be updated during an event.");throw t.behavior=e,t}e.untrackedDynamicDemands=t,this.modifiedDemandBehaviors.push(e)}updateSupplies(e,t){if(null==e.extent.addedToGraphWhen){let t=new Error("Behavior must belong to graph before updating supplies.");throw t.behavior=e,t}if(null==this.currentEvent){let t=new Error("Supplies can only be updated during an event.");throw t.behavior=e,t}e.untrackedDynamicSupplies=t,this.modifiedSupplyBehaviors.push(e)}removeBehavior(e,t){if(null!=e.demands){let t=!1;for(let i of e.demands)i.extent!=e.extent&&(i.subsequents.delete(e),t=!0);t&&e.demands.clear()}if(null!=e.supplies){let t=!1;for(let i of e.supplies)i.extent!=e.extent&&(i.suppliedBy=null,t=!0);t&&e.supplies.clear()}e.removedWhen=t}addExtent(e){if(null!=e.addedToGraphWhen){let t=new Error("Extent already belongs to a graph.");throw t.extent=e,t.graph=this,t}if(null==this.currentEvent){let t=new Error("Extents can only be added during an event.");throw t.extent=e,t}if(this.validateLifetimes&&null!=e.lifetime&&(null==e.lifetime.addedToGraphWhen&&(e.lifetime.addedToGraphWhen=this.currentEvent.sequence),null!=e.lifetime.parent&&null==e.lifetime.parent.addedToGraphWhen)){let t=new Error("Extent with child lifetime must be added after parent.");throw t.extent=e,t}e.addedToGraphWhen=this.currentEvent.sequence,this.extentsAdded.push(e),e.addedToGraph._updateForce(!0);for(let t of e.behaviors)this.addBehavior(t)}removeExtent(e){if(null==this.currentEvent){let t=new Error("Extents can only be removed during an event.");throw t.extent=e,t}this.extentsRemoved.push(e);for(let t of e.behaviors)this.removeBehavior(t,this.currentEvent.sequence);e.addedToGraphWhen=null}},e.GraphEvent=h,e.Moment=s,e.Resource=r,e.State=a,Object.defineProperty(e,"__esModule",{value:!0}),e}({});
//# sourceMappingURL=/sm/4c2209e98b87fc75793f4dfb2369ae9ea545ea8b4d4ca9796cc615c6e9e4cdf1.map